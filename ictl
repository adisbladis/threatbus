#!/usr/bin/env python

import argparse
import asyncio
import datetime
import json
import maya
import os
import sys
import urllib.parse
import zmq
from zmq.asyncio import Context

from pymisp import PyMISP, MISPAttribute, MISPSighting

MISP_DEFAULT_HOST = "localhost"
MISP_DEFAULT_WEB_PORT = 80
MISP_DEFAULT_ZMQ_PORT = 50000
VAST_PORT = 42000

# -- utilities ----------------------------------------------------------------

# Poor man's logging.
def log(*args, color="cyan"):
    def to_color(col):
        if col == "red":
            return 31
        if col == "green":
            return 32
        if col == "yellow":
            return 33
        if col == "blue":
            return 34
        if col == "magenta":
            return 35
        if col == "cyan":
            return 36
        sys.exit(1)
    """Prints logging output to standard error"""
    line = " ".join(map(str, args))
    print(f"\033[{to_color(color)}m", line, "\033[0m", sep="", file=sys.stderr)

def make_zmq_socket(host, port, kind):
    assert kind == zmq.SUB or zmq.PUB
    context = Context.instance()
    socket = context.socket(kind)
    socket.connect(f"tcp://{host}:{port}")
    option = zmq.SUBSCRIBE if zmq.SUB else zmq.PUBLISH
    socket.setsockopt(option, b"")
    return socket

def str_escape(x):
    return '"' + x.replace('"','\\"') + '"'

def make_conjunction(xs):
    return "({})".format(" && ".join(xs))

def make_disjunction(xs):
    return "({})".format(" || ".join(xs))

def make_predicate(attribute_type, values):
    assert values
    # Combine singleton values into a set query.
    def condense(lhs, rhs):
        if len(rhs) == 1:
            return f"{lhs} == {rhs[0]}"
        else:
            return f"{lhs} in {{{', '.join(rhs)}}}"
    # IP addresses
    if attribute_type in ["ip-src", "ip-dst"]:
        return condense(":addr", values)
    # URLs
    elif attribute_type in ["url", "uri"]:
        def make_http_log_expr(x):
            result = urllib.parse.urlsplit(x)
            host = result.hostname
            path = result.path
            if not host and path and path[0] != "/":
                # If there is no protocol in the URI, then the "host" part will
                # be prepended to "path". We're "fixing" this behavior by
                # manually splitting at the first "/".
                host, path = tuple(path.split("/", 1))
                path = "/" + path # bring back leading slash
            host = f"host == {str_escape(host)}" if host else None
            path = f"uri == {str_escape(path)}" if path else None
            if host and path:
                return make_conjunction([host, path])
            if host:
                return host
            if path:
                return path
            return None
        return make_disjunction(map(make_http_log_expr, values))
    # Domains
    elif attribute_type == "domain":
        return condense("host", list(map(str_escape, values)))
    # Other
    elif attribute_type == "http-method":
        return condense("method", list(map(str_escape, values)))
    else:
        log("unsupported attribute type:", attribute_type)
        sys.exit(1)

def make_query(attributes):
    """Creates a VAST expression from MISP attributes."""
    xs = {}
    for attr in attributes:
        xs.setdefault(attr.type, []).append(attr.value)
    predicates = [make_predicate(k, v) for (k, v) in xs.items()]
    return make_disjunction(predicates)

def make_sighting(attr_id, timestamp):
    x = MISPSighting()
    x.from_dict(id=attr_id, source="VAST", type="0", timestamp=timestamp)
    return x

async def spawn(*args, stderr_color="magenta"):
    """Spawns a process asynchronously."""
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    log(stderr.decode().strip(), color=stderr_color)
    return stdout.decode().strip()

async def export(app, query):
    assert app == "vast" or "tenzir"
    log(f"spawning {app} process for expression {query}")
    return await spawn(app, "export", "json", query, stderr_color="green")

# -- types --------------------------------------------------------------------

class Controller:
    def __init__(self, app, host, web_port, zmq_port):
        log(f"using '{app}' for historical queries")
        self.app = app
        # Connect to MISP instance via API.
        if "MISP_API_KEY" not in os.environ:
            log("no environment variable MISP_API_KEY found")
            sys.exit(1)
        api_key = os.environ['MISP_API_KEY']
        url = f"http://{host}:{web_port}"
        log(f"connecting to MISP REST API at {url}")
        self.misp = PyMISP(url, api_key, ssl=False, debug=False)
        # Connect to MISP via 0mq.
        log(f"subcribing to MISP 0mq socket at {host}:{zmq_port}")
        self.zmq_sub_socket = make_zmq_socket(host, zmq_port, zmq.SUB)

    async def historical_query(self, values, window=None):
        attributes = await self.__historical_misp_query(values)
        if attributes:
            await self.__run_query(attributes, window)
        else:
            log("MISP has no indicators for", values)

    async def continuous_query(self, values, window=None):
        await self.__continuous_misp_query(values, window)

    async def __continuous_misp_query(self, values, window):
        assert self.zmq_sub_socket
        log("running in continuous query mode")
        if values:
            log(f"restricting query to values {values}")
        while True:
            msg = await self.zmq_sub_socket.recv()
            topic, _, payload = msg.decode("utf-8").partition(" ")
            # Filter out heartbeats.
            if topic == "misp_json_self":
                uptime = int(json.loads(payload)["uptime"])
                delta = datetime.timedelta(seconds=uptime)
                log("received keep-alive (uptime", "{:0>8})".format(str(delta)))
                continue
            if topic != "misp_json_attribute":
                continue
            # Parse the payload.
            data = json.loads(payload)
            attr = data["Attribute"]
            action = data["action"]
            # Consider only new events.
            if action != "add":
                log(f"ignoring '{action}' of attribute {attr['id']}")
                continue
            log(json.dumps(data, indent=2), color="yellow")
            if values and attr["value"] not in values:
                continue
            misp_attr = MISPAttribute()
            misp_attr.from_dict(**attr)
            asyncio.create_task(self.__run_query([misp_attr], window))

    async def __historical_misp_query(self, values, attr_type=None, start=None):
        assert self.misp
        log("executing historical query for", values)
        if attr_type:
            log("restricting search to type", attr_type)
        return self.misp.search(controller="attributes",
                                  date_from=start,
                                  type_attribute=attr_type,
                                  values=values,
                                  pythonify=True)

    async def __run_query(self, attributes, window):
        make_ts = lambda x: datetime.datetime.utcfromtimestamp(int(x))
        # Get all events for the given set of attributes.
        expr = make_query(attributes)
        if window:
            expr = f"&time > now - {window} && {expr}"
        stdout = await export(self.app, expr)
        results = stdout.splitlines()
        log(f"processing {len(results)} results")
        for result in results:
            log(result, color="blue")
            record = json.loads(result)
            # Extract time of sighting.
            if "ts" not in record:
                log("couldn't find Zeek log with 'ts' column")
                sys.exit(1)
            timestamp = int(record["ts"])
            # Create a list of sightings, one for each attribute.
            xs = [make_sighting(x.id, timestamp) for x in attributes]
            log(f"publishing sighting for {len(xs)} attributes", "at",
                make_ts(timestamp).strftime('%Y-%m-%d %H:%M:%S'), color="red")
            # Publish sightings to MISP.
            self.misp.set_sightings(xs)

# -- main ---------------------------------------------------------------------

async def main():
    """The main function"""
    parser = argparse.ArgumentParser(
        description=os.path.basename(__file__),
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-a",
        "--app",
        default="tenzir",
        help="Path to the VAST/Tenzir executable")
    parser.add_argument(
        "-m",
        "--misp-host",
        default=MISP_DEFAULT_HOST,
        help="The host where the MISP instance is running")
    parser.add_argument(
        "-z",
        "--zmq-port",
        type=int,
        default=MISP_DEFAULT_ZMQ_PORT,
        help="The ZeroMQ port of the MISP instance")
    parser.add_argument(
        "-w",
        "--web-port",
        type=int,
        default=MISP_DEFAULT_WEB_PORT,
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "-H",
        "--historical",
        action='store_true',
        help="Perform a historical query through the REST API")
    parser.add_argument(
        "-C",
        "--continuous",
        action='store_true',
        help="Perform a continuous query by subscribing via 0mq")
    parser.add_argument(
        "-U",
        "--unified",
        action='store_true',
        help="Perform a historical and continuous query")
    parser.add_argument(
        "-t",
        "--time-window",
        help="The time window to restrict intel searches to")
    parser.add_argument("values", nargs=argparse.REMAINDER)
    args = parser.parse_args()
    # Create a MISP Controller.
    controller = Controller(args.app, args.misp_host, args.web_port,
                            args.zmq_port)
    # Run historical query.
    if args.historical or args.unified:
        if not args.values:
            log("historical queries requires at least one value")
            sys.exit(1)
        await controller.historical_query(args.values, args.time_window)
    # Subscribe to future results.
    if args.continuous or args.unified:
        await controller.continuous_query(args.values, args.time_window)

if __name__ == '__main__':
    asyncio.run(main())
