#!/usr/bin/env python

import argparse
import asyncio
import datetime
import json
import maya
import os
import sys
from typing import NamedTuple
import urllib.parse
import zmq
from zmq.asyncio import Context

from pymisp import PyMISP, MISPAttribute, MISPSighting

MISP_DEFAULT_HOST = "localhost"
MISP_DEFAULT_WEB_PORT = 80
MISP_DEFAULT_ZMQ_PORT = 50000
VAST_PORT = 42000

# -- utilities ----------------------------------------------------------------

# Poor man's logging.
def log(*args, color="cyan"):
    def to_color(col):
        if col == "red":
            return 31
        if col == "green":
            return 32
        if col == "yellow":
            return 33
        if col == "blue":
            return 34
        if col == "magenta":
            return 35
        if col == "cyan":
            return 36
        sys.exit(1)
    """Prints logging output to standard error"""
    line = " ".join(map(str, args))
    print(f"\033[{to_color(color)}m", line, "\033[0m", sep="", file=sys.stderr)

def fail(*args):
    log(*args, color="red")
    sys.exit(1)

def make_zmq_socket(host, port, kind):
    assert kind == zmq.SUB or zmq.PUB
    context = Context.instance()
    socket = context.socket(kind)
    socket.connect(f"tcp://{host}:{port}")
    option = zmq.SUBSCRIBE if zmq.SUB else zmq.PUBLISH
    socket.setsockopt(option, b"")
    return socket

def str_escape(x):
    return '"' + x.replace('"','\\"') + '"'
def make_sighting(attr_id, timestamp):
    x = MISPSighting()
    x.from_dict(id=attr_id, source="VAST", type="0", timestamp=timestamp)
    return x

async def spawn(*args, stderr_color="magenta"):
    """Spawns a process asynchronously."""
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    log(stderr.decode().strip(), color=stderr_color)
    return stdout.decode().strip()

# -- types --------------------------------------------------------------------

class Intelligence(NamedTuple):
    id: str         # A unique identifier (within the producer's context).
    type: str       # The type of intelligence.
    value: str      # The value of the item.
    data: str       # The raw data as given by the source
    producer: str   # The origin of the intelligence.

class MISP:
    """Subscribes to MISP's ZeroMQ channel that publishes intel."""
    def __init__(self, host, web_port, zmq_port):
        # Connect to MISP instance via API.
        if "MISP_API_KEY" not in os.environ:
            fail("no environment variable MISP_API_KEY found")
        api_key = os.environ['MISP_API_KEY']
        api_url = f"http://{host}:{web_port}"
        log(f"connecting to MISP REST API at {api_url}")
        self.misp = PyMISP(api_url, api_key, ssl=False, debug=False)
        # Connect to MISP via 0mq.
        zmq_url = f"tcp://{host}:{zmq_port}"
        log(f"connecting to MISP 0mq socket at {zmq_url}")
        context = Context.instance()
        self.socket = context.socket(zmq.SUB)
        self.socket.connect(zmq_url)
        self.socket.setsockopt(zmq.SUBSCRIBE, b"")

    async def intel(self):
        while True:
            msg = await self.socket.recv()
            topic, _, payload = msg.decode("utf-8").partition(" ")
            # Filter out heartbeats.
            if topic == "misp_json_self":
                uptime = int(json.loads(payload)["uptime"])
                delta = datetime.timedelta(seconds=uptime)
                log("received 0mq keep-alive (uptime",
                    "{:0>8})".format(str(delta)))
                continue
            if topic != "misp_json_attribute":
                continue
            # Parse the payload.
            data = json.loads(payload)
            attr = data["Attribute"]
            action = data["action"]
            # Consider only new events.
            if action not in ["add", "edit"]:
                log(f"ignoring '{action}' of attribute {attr['id']}")
                continue
            log(json.dumps(data, indent=2), color="yellow")
            # Instantiate the intel item.
            misp_attr = MISPAttribute()
            misp_attr.from_dict(**attr)
            return Intelligence(
                id=misp_attr.id,
                type=misp_attr.type,
                value=misp_attr.value,
                data=misp_attr,
                producer="misp")

    async def report(self, intel, time_seen):
        """Reports intelligence as (true-positive) sighting."""
        x = MISPSighting()
        x.from_dict(id=intel.id, source="VAST", type="0", timestamp=time_seen)
        ts = datetime.datetime.utcfromtimestamp(time_seen)
        log(f"reporting intel seen at", ts.strftime('%Y-%m-%d %H:%M:%S'))
        self.misp.set_sightings(x)

    async def search(self, values, attr_type=None, start=None):
        """Performs a search over MISP attributes"""
        log("searching MISP database for", values)
        if attr_type:
            log("restricting search to type", attr_type)
        return self.misp.search(controller="attributes",
                                date_from=start,
                                type_attribute=attr_type,
                                values=values,
                                pythonify=True)

class VAST:
    def __init__(self, path, max_results=10):
        self.app = path
        self.max_results = max_results
        log(f"capping VAST results at '{self.max_results}' events")

    async def status(self):
        try:
            return json.loads(await spawn(self.app, "status"))
        except json.decoder.JSONDecodeError:
            fail(f"failed to connect to remote VAST node")
        except FileNotFoundError:
            fail(f"could not find {self.app} in PATH")

    async def export(self, expr, window=None):
        log(f"spawning {self.app} process for expression {expr}")
        stdout = await spawn(self.app, "export", "-e", str(self.max_results),
                             "json", expr)
        return stdout.splitlines()

    @staticmethod
    def make_conjunction(xs):
        return "({})".format(" && ".join(xs))

    @staticmethod
    def make_disjunction(xs):
        return "({})".format(" || ".join(xs))

    @staticmethod
    def make_predicate(intel_type, values):
        assert values
        # Combine singleton values into a set query.
        def condense(lhs, rhs):
            if len(rhs) == 1:
                return f"{lhs} == {rhs[0]}"
            else:
                return f"{lhs} in {{{', '.join(rhs)}}}"
        # IP addresses
        if intel_type in ["ip-src", "ip-dst"]:
            return condense(":addr", values)
        # URLs
        elif intel_type in ["url", "uri"]:
            def make_http_log_expr(x):
                result = urllib.parse.urlsplit(x)
                host = result.hostname
                path = result.path
                if not host and path and path[0] != "/":
                    # If there is no protocol in the URI, then the "host" part will
                    # be prepended to "path". We're "fixing" this behavior by
                    # manually splitting at the first "/".
                    host, path = tuple(path.split("/", 1))
                    path = "/" + path # bring back leading slash
                host = f"host == {str_escape(host)}" if host else None
                path = f"uri == {str_escape(path)}" if path else None
                if host and path:
                    return VAST.make_conjunction([host, path])
                if host:
                    return host
                if path:
                    return path
                return None
            return VAST.make_disjunction(map(make_http_log_expr, values))
        # Domains
        elif intel_type == "domain":
            return condense("host", list(map(str_escape, values)))
        # Other
        elif intel_type == "http-method":
            return condense("method", list(map(str_escape, values)))
        else:
            fail("unsupported intel type:", intel_type)

    @staticmethod
    def make_expression(intel, window=None):
        """Creates a VAST expression from an intel item."""
        # FIXME: type queries currently prevent this from working.
        #filter = '#type == "zeek::conn"'
        #if window:
        #    filter = f"#time > {window} ago && {filter}"
        #pred = VAST.make_predicate(intel.type, [intel.value])
        #return f'{filter} && {pred}'
        return VAST.make_predicate(intel.type, [intel.value])


class Controller:
    def __init__(self, vast, misp):
        self.vast = vast
        self.misp = misp

    async def run(self, window=None):
        while True:
            intel = await self.misp.intel()
            expr = VAST.make_expression(intel, window)
            results = await self.vast.export(expr)
            log(f"reporting sightings for {len(results)} results")
            for result in results:
                log(result, color="blue")
                record = json.loads(result)
                # Extract time of sighting.
                if "ts" not in record:
                    fail("couldn't find Zeek log with 'ts' column")
                timestamp = int(record["ts"])
                # Report sightings back to producer.
                await self.misp.report(intel, timestamp)

# -- main ---------------------------------------------------------------------

async def main():
    """The main function"""
    parser = argparse.ArgumentParser(
        description="The Robo Investigor autonomously correlates threat "
        "intelligence with historical data to uncover attacks that began in "
        "the past. Matching activity is published back to the intelligence "
        "providers to confirm sightings",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-m",
        "--misp-host",
        default=MISP_DEFAULT_HOST,
        help="The host where the MISP instance is running")
    parser.add_argument(
        "-z",
        "--zmq-port",
        type=int,
        default=MISP_DEFAULT_ZMQ_PORT,
        help="The ZeroMQ port of the MISP instance")
    parser.add_argument(
        "-w",
        "--web-port",
        type=int,
        default=MISP_DEFAULT_WEB_PORT,
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "-t",
        "--time-window",
        help="The time window to restrict intel searches to")
    parser.add_argument(
        "-v",
        "--vast",
        default="tenzir",
        help="Path to the VAST executable")
#    parser.add_argument(
#        "-z",
#        "--zeek-host",
#        help="The Zeek node to which to relay new intel")
    parser.add_argument("values", nargs=argparse.REMAINDER)
    args = parser.parse_args()
    # Setup VAST
    vast = VAST(args.vast)
    vast_status = await vast.status()
    vast_threads = vast_status['system']['worker-threads']
    log(f"found VAST running with {vast_threads} threads")
    # Setup MISP.
    misp = MISP(args.misp_host, args.web_port, args.zmq_port)
    # Create controller.
    controller = Controller(vast, misp)
    log(f"waiting for new intel")
    await controller.run(args.time_window)

if __name__ == '__main__':
    asyncio.run(main())
