#!/usr/bin/env python

import argparse
import asyncio
import datetime
import json
import logging
import os
from shutil import which
import sys
from typing import NamedTuple
import urllib.parse

from aiokafka import AIOKafkaConsumer
import confuse
import zmq
from zmq.asyncio import Context
from pymisp import PyMISP, MISPAttribute, PyMISPError, MISPSighting

ZEEK_INTEGRATION = True
try:
    import broker
    import broker.bro
except ImportError:
    ZEEK_INTEGRATION = False

# -- utilities ----------------------------------------------------------------

# Poor man's logging.
def log(*args, color="cyan"):
    def to_color(col):
        if col == "red":
            return 31
        if col == "green":
            return 32
        if col == "yellow":
            return 33
        if col == "blue":
            return 34
        if col == "magenta":
            return 35
        if col == "cyan":
            return 36
        sys.exit(1)
    """Prints logging output to standard error"""
    line = " ".join(map(str, args))
    print(f"\033[{to_color(color)}m", line, "\033[0m", sep="", file=sys.stderr)

def fail(*args):
    log(*args, color="red")
    sys.exit(1)

def str_escape(x):
    return '"' + x.replace('"','\\"') + '"'

async def spawn(*args, stderr_color="magenta"):
    """Spawns a process asynchronously."""
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    log(stderr.decode().strip(), color=stderr_color)
    return stdout.decode().strip()

# -- types --------------------------------------------------------------------

class Intelligence(NamedTuple):
    id: str         # A unique identifier (within the intel source's context).
    type: str       # The type of intelligence.
    value: str      # The value of the item.
    data: str       # The raw data as given by the source
    source: str     # The origin of the intelligence.

class MISP:
    def __init__(self, config):
        # Connect to MISP instance via API.
        if "MISP_API_KEY" not in os.environ:
            fail("no environment variable MISP_API_KEY found")
        api_key = os.environ['MISP_API_KEY'] or config.rest.api_key
        api_url = f"http://{config.rest.host}:{config.rest.port}"
        log(f"connecting to MISP REST API at {api_url}")
        try:
            self.misp = PyMISP(api_url, config.rest.api_key,
                               ssl=config.rest.ssl)
        except PyMISPError:
            fail(f"connection refused while trying to connect to {api_url}")

    def subscribe(self, channel):
        if type(channel) == AIOKafkaConsumer:
            async def generate():
                try:
                    while True:
                        msg = await channel.getone()
                        data  = json.loads(msg.value)
                        intel = MISP.make_intel_from_attribute(data)
                        if intel:
                            return intel
                except:
                    await channel.stop()
                    fail("failure during Kafka attribute consumption:",
                         sys.exc_info())
            self.generator = generate
        elif type(channel) == zmq.asyncio.Socket:
            async def generate():
                while True:
                    msg = await channel.recv()
                    topic, _, payload = msg.decode("utf-8").partition(" ")
                    # Filter out heartbeats.
                    if topic == "misp_json_self":
                        uptime = int(json.loads(payload)["uptime"])
                        delta = datetime.timedelta(seconds=uptime)
                        log("received 0mq keep-alive (uptime",
                            "{:0>8})".format(str(delta)))
                        continue
                    if topic != "misp_json_attribute":
                        continue
                    # Parse the payload.
                    data = json.loads(payload)
                    result = MISP.make_intel_from_attribute(data)
                    if result:
                        return result
            self.generator = generate
        else:
            fail(f"unknown channel type {type(channel)}")

    async def unsubscribe(self, channel):
        if type(channel) == AIOKafkaConsumer:
            await channel.stop()
        elif type(channel) == zmq.Socket:
            channel.disconnect()

    async def intel(self):
        return await self.generator()

    async def report(self, intel, time_seen):
        """Reports intelligence as (true-positive) sighting."""
        x = MISPSighting()
        x.from_dict(id=intel.id, source="VAST", type="0", timestamp=time_seen)
        ts = datetime.datetime.utcfromtimestamp(time_seen)
        log(f"reporting intel seen at", ts.strftime('%Y-%m-%d %H:%M:%S'))
        self.misp.set_sightings(x)

    async def search(self, values, attr_type=None, start=None):
        """Performs a search over MISP attributes"""
        log("searching MISP database for", values)
        if attr_type:
            log("restricting search to type", attr_type)
        return self.misp.search(controller="attributes",
                                date_from=start,
                                type_attribute=attr_type,
                                values=values,
                                pythonify=True)

    @staticmethod
    def make_intel_from_attribute(data):
        attr = data["Attribute"]
        action = data["action"]
        # Consider only new events.
        if action not in ["add", "edit"]:
            log(f"ignoring '{action}' of attribute {attr['id']}")
            return None
        log(json.dumps(data, indent=2), color="yellow")
        # Instantiate the intel item.
        misp_attr = MISPAttribute()
        misp_attr.from_dict(**attr)
        return Intelligence(
            id=misp_attr.id,
            type=misp_attr.type,
            value=misp_attr.value,
            data=misp_attr,
            source="misp")

class VAST:
    def __init__(self, config):
        self.app = config.executable
        self.window = config.time_window
        self.max_results = config.max_results
        log(f"capping VAST results at '{self.max_results}' events")

    def make_expression(self, intel):
        """Creates a VAST expression from an intel item."""
        # FIXME: type queries currently prevent this from working.
        #filter = '#type == "zeek::conn"'
        #if self.window:
        #    filter = f"#time > {self.window} ago && {filter}"
        #pred = VAST.make_predicate(intel.type, [intel.value])
        #return f'{filter} && {pred}'
        return VAST.make_predicate(intel.type, [intel.value])

    async def status(self):
        try:
            return json.loads(await spawn(self.app, "status"))
        except json.decoder.JSONDecodeError:
            fail(f"failed to connect to remote VAST node")
        except FileNotFoundError:
            fail(f"could not find {self.app} in PATH")

    async def export(self, expr, window=None):
        log(f"spawning {self.app} process for expression {expr}")
        stdout = await spawn(self.app, "export", "-e", str(self.max_results),
                             "json", expr)
        return stdout.splitlines()

    def path(self):
        """Retrieves the full path to the VAST binary"""
        return self.app

    @staticmethod
    def make_conjunction(xs):
        return "({})".format(" && ".join(xs))

    @staticmethod
    def make_disjunction(xs):
        return "({})".format(" || ".join(xs))

    @staticmethod
    def make_predicate(intel_type, values):
        assert values
        # Combine singleton values into a set query.
        def condense(lhs, rhs):
            if len(rhs) == 1:
                return f"{lhs} == {rhs[0]}"
            else:
                return f"{lhs} in {{{', '.join(rhs)}}}"
        # IP addresses
        if intel_type in ["ip-src", "ip-dst"]:
            return condense(":addr", values)
        # URLs
        elif intel_type in ["url", "uri"]:
            def make_http_log_expr(x):
                result = urllib.parse.urlsplit(x)
                host = result.hostname
                path = result.path
                if not host and path and path[0] != "/":
                    # If there is no protocol in the URI, then the "host" part will
                    # be prepended to "path". We're "fixing" this behavior by
                    # manually splitting at the first "/".
                    host, path = tuple(path.split("/", 1))
                    path = "/" + path # bring back leading slash
                host = f"host == {str_escape(host)}" if host else None
                path = f"uri == {str_escape(path)}" if path else None
                if host and path:
                    return VAST.make_conjunction([host, path])
                if host:
                    return host
                if path:
                    return path
                return None
            return VAST.make_disjunction(map(make_http_log_expr, values))
        # Domains
        elif intel_type == "domain":
            return condense("host", list(map(str_escape, values)))
        # Other
        elif intel_type == "http-method":
            return condense("method", list(map(str_escape, values)))
        else:
            fail("unsupported intel type:", intel_type)

class Zeek:
    def __init__(self, config):
        self.config = config
        self.endpoint = broker.Endpoint()
        log(f"establishing peering with Zeek at {config.host}:{config.port}")
        self.endpoint.peer(config.host, config.port)
        log("established peering succesfully")

    def add(self, intel):
        """Forwards intelligence to Zeek"""
        log("forwarding intel to Zeek:", intel)
        event = broker.bro.Event(
            "Tenzir::add_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value,
            intel.source)
        self.endpoint.publish(self.config.topic, event)

    def remove(self, intel):
        """Forwards intelligence to Zeek"""
        log("deleting intel from Zeek:", intel)
        event = broker.bro.Event(
            "Tenzir::remove_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value)
        self.endpoint.publish(self.config.topic, event)

    @staticmethod
    def misp_to_intel_framework_type(intel):
        """Translates type names of internal intel to names in Zeek's intel
        framework."""
        # TODO: complete mapping MISP types to Zeek types.
        table = {
            "ip-src": "ADDR",
            "ip-dst": "ADDR",
            "domain": "DOMAIN",
            "email-dst": "EMAIL",
            "email-src": "EMAIL",
            "email-reply-to": "EMAIL",
            "hostname": "DOMAIN",
            "url": "URL",
            "uri": "URL",
            "x509-fingerprint-md5": "CERT_HASH",
            "x509-fingerprint-sha1": "CERT_HASH",
            "x509-fingerprint-sha256": "CERT_HASH",
        }
        return table[intel.type]


class Controller:
    def __init__(self, vast, misp, zeek):
        self.vast = vast
        self.misp = misp
        self.zeek = zeek

    async def run(self):
        while True:
            intel = await self.misp.intel()
            if self.vast:
                expr = self.vast.make_expression(intel)
                results = await self.vast.export(expr)
                log(f"reporting sightings for {len(results)} results")
                for result in results:
                    log(result, color="blue")
                    record = json.loads(result)
                    if "ts" not in record:
                        fail("couldn't find Zeek log with 'ts' column")
                    timestamp = int(record["ts"])
                    await self.misp.report(intel, timestamp)
            if self.zeek:
                self.zeek.add(intel)

# -- main ---------------------------------------------------------------------

# The valid schema for the configuration.
template = {
    'consumers': confuse.StrSeq(),
    'producers': confuse.StrSeq(),
    'misp': {
        'channel': confuse.OneOf(['zmq', 'kafka']),
        'zmq': {
            'host': str,
            'port': int,
        },
        'kafka': {
            'host': str,
            'attribute_topic': str,
        },
        'rest': {
            'host': str,
            'port': int,
            'ssl': bool,
            'api_key': str,
        }
    },
    'zeek': {
        'host': str,
        'port': int,
        'topic': str,
    },
    'vast': {
        'executable': str,
        'max_results': int,
        'time_window': str,
    },
}

async def main():
    """The main function"""
    lazy_config = confuse.LazyConfig('RoboInvestigator', __name__)
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--config',
        '-c',
        help='path to a configuration file')
    parser.add_argument(
        '--verbose',
        '-v',
        dest='verbose',
        action='store_true',
        help='print debugging messages')
    # MISP
    parser.add_argument(
        "--misp-rest-host",
        "-m",
        dest="misp.rest.host",
        help="The REST API host of the MISP instance")
    parser.add_argument(
        "--misp-kafka-host",
        "-k",
        dest="misp.kafka.host",
        help="The Kafka bootstrap server configured with MISP")
    parser.add_argument(
        "--zeek-host",
        "-z",
        dest="zeek.host",
        help="The Zeek host running the integration scripts")
    args = parser.parse_args()
    if args.config:
        lazy_config.set_file(args.config)
    lazy_config.set_args(args, dots=True)
    config = lazy_config.get(template)

    # Setup VAST
    vast = None
    if "vast" in config.consumers:
        if not config.vast.executable:
            fail(f"could not find VAST at {config.vast.executable}")
        vast = VAST(config.vast)
        vast_status = await vast.status()
        vast_threads = vast_status['system']['worker-threads']
        log(f"found VAST running with {vast_threads} threads")
    # Setup MISP.
    misp = None
    if "misp" in config.producers:
        misp = MISP(config.misp)
        if config.misp.channel == "zmq":
            zmq_url = f"tcp://{config.misp.zmq.host}:{config.misp.zmq.port}"
            log(f"connecting to MISP 0mq socket at {zmq_url}")
            context = Context.instance()
            socket = context.socket(zmq.SUB)
            socket.connect(zmq_url)
            socket.setsockopt(zmq.SUBSCRIBE, b"")
            misp.subscribe(socket)
        elif config.misp.channel == "kafka":
            log("subscribing to MISP Kafka publisher at "
                f"{config.misp.kafka.host} at topic "
                f"{config.misp.kafka.attribute_topic}")
            consumer = AIOKafkaConsumer(
                config.misp.kafka.attribute_topic,
                loop=asyncio.get_event_loop(),
                bootstrap_servers=args.config.misp.kafka.host)
            await consumer.start()
            misp.subscribe(consumer)
        else:
            fail("need an intel subscription either via Kafka or 0mq")
    # Connect to Zeek.
    zeek = None
    if "zeek" in config.consumers:
        if not ZEEK_INTEGRATION:
            fail("no broker python module found")
        zeek = Zeek(config.zeek)
    # Create controller.
    if not misp:
        fail("MISP intel producer not provided") # currently mandatory
    if not (vast or zeek):
        fail("no intel consumer provided; enable VAST or Zeek")
    controller = Controller(vast, misp, zeek)
    log("waiting for new intel")
    await controller.run()

if __name__ == '__main__':
    asyncio.run(main())
