#!/usr/bin/env python

from aiokafka import AIOKafkaConsumer
import argparse
import asyncio
import datetime
import json
import maya
import os
from shutil import which
import sys
from typing import NamedTuple
import urllib.parse
import zmq
from zmq.asyncio import Context



from pymisp import PyMISP, MISPAttribute, PyMISPError, MISPSighting

ZEEK_TOPIC = "tenzir/robo"
ZEEK_DEFAULT_HOST = "localhost"
ZEEK_DEFAULT_PORT = 54321
ZEEK_INTEGRATION = True
try:
    import broker
    import broker.bro
except ImportError:
    ZEEK_INTEGRATION = False

MISP_DEFAULT_HOST = "localhost"
MISP_DEFAULT_WEB_PORT = 80
MISP_DEFAULT_ZMQ_PORT = 50000
MISP_DEFAULT_KAFKA_ATTRIBUTE_TOPIC = "misp_attribute"
MISP_DEFAULT_KAFKA_BOOTSTRAP_SERVER = "localhost"

# -- utilities ----------------------------------------------------------------

# Poor man's logging.
def log(*args, color="cyan"):
    def to_color(col):
        if col == "red":
            return 31
        if col == "green":
            return 32
        if col == "yellow":
            return 33
        if col == "blue":
            return 34
        if col == "magenta":
            return 35
        if col == "cyan":
            return 36
        sys.exit(1)
    """Prints logging output to standard error"""
    line = " ".join(map(str, args))
    print(f"\033[{to_color(color)}m", line, "\033[0m", sep="", file=sys.stderr)

def fail(*args):
    log(*args, color="red")
    sys.exit(1)

def make_zmq_socket(host, port, kind):
    assert kind == zmq.SUB or zmq.PUB
    context = Context.instance()
    socket = context.socket(kind)
    socket.connect(f"tcp://{host}:{port}")
    option = zmq.SUBSCRIBE if zmq.SUB else zmq.PUBLISH
    socket.setsockopt(option, b"")
    return socket

def str_escape(x):
    return '"' + x.replace('"','\\"') + '"'
def make_sighting(attr_id, timestamp):
    x = MISPSighting()
    x.from_dict(id=attr_id, source="VAST", type="0", timestamp=timestamp)
    return x

async def spawn(*args, stderr_color="magenta"):
    """Spawns a process asynchronously."""
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    log(stderr.decode().strip(), color=stderr_color)
    return stdout.decode().strip()

# -- types --------------------------------------------------------------------

class Intelligence(NamedTuple):
    id: str         # A unique identifier (within the intel source's context).
    type: str       # The type of intelligence.
    value: str      # The value of the item.
    data: str       # The raw data as given by the source
    source: str     # The origin of the intelligence.

class MISP:
    def __init__(self, host, web_port):
        # Connect to MISP instance via API.
        if "MISP_API_KEY" not in os.environ:
            fail("no environment variable MISP_API_KEY found")
        api_key = os.environ['MISP_API_KEY']
        api_url = f"http://{host}:{web_port}"
        log(f"connecting to MISP REST API at {api_url}")
        try:
            self.misp = PyMISP(api_url, api_key, ssl=False, debug=False)
        except PyMISPError:
            fail(f"connection refused while trying to connect to {api_url}")

    def __del__(self):
        if self.cleanup:
            self.cleanup()


    def subscribe(self, channel):
        if type(channel) == AIOKafkaConsumer:
            async def generate():
                try:
                    while True:
                        msg = await channel.getone()
                        data  = json.loads(msg.value)
                        intel = MISP.make_intel_from_attribute(data)
                        if intel:
                            return intel
                except:
                    await channel.stop()
                    fail("failure during Kafka attribute consumption:",
                         sys.exc_info())
            self.generator = generate
        elif type(channel) == zmq.asyncio.Socket:
            async def generate():
                while True:
                    msg = await channel.recv()
                    topic, _, payload = msg.decode("utf-8").partition(" ")
                    # Filter out heartbeats.
                    if topic == "misp_json_self":
                        uptime = int(json.loads(payload)["uptime"])
                        delta = datetime.timedelta(seconds=uptime)
                        log("received 0mq keep-alive (uptime",
                            "{:0>8})".format(str(delta)))
                        continue
                    if topic != "misp_json_attribute":
                        continue
                    # Parse the payload.
                    data = json.loads(payload)
                    result = MISP.make_intel_from_attribute(data)
                    if result:
                        return result
            self.generator = generate
        else:
            fail(f"unknown channel type {type(channel)}")

    async def unsubscribe(self, channel):
        if type(channel) == AIOKafkaConsumer:
            await channel.stop()
        elif type(channel) == zmq.Socket:
            channel.disconnect()

    async def intel(self):
        return await self.generator()

    async def report(self, intel, time_seen):
        """Reports intelligence as (true-positive) sighting."""
        x = MISPSighting()
        x.from_dict(id=intel.id, source="VAST", type="0", timestamp=time_seen)
        ts = datetime.datetime.utcfromtimestamp(time_seen)
        log(f"reporting intel seen at", ts.strftime('%Y-%m-%d %H:%M:%S'))
        self.misp.set_sightings(x)

    async def search(self, values, attr_type=None, start=None):
        """Performs a search over MISP attributes"""
        log("searching MISP database for", values)
        if attr_type:
            log("restricting search to type", attr_type)
        return self.misp.search(controller="attributes",
                                date_from=start,
                                type_attribute=attr_type,
                                values=values,
                                pythonify=True)

    @staticmethod
    def make_intel_from_attribute(data):
        attr = data["Attribute"]
        action = data["action"]
        # Consider only new events.
        if action not in ["add", "edit"]:
            log(f"ignoring '{action}' of attribute {attr['id']}")
            return None
        log(json.dumps(data, indent=2), color="yellow")
        # Instantiate the intel item.
        misp_attr = MISPAttribute()
        misp_attr.from_dict(**attr)
        return Intelligence(
            id=misp_attr.id,
            type=misp_attr.type,
            value=misp_attr.value,
            data=misp_attr,
            source="misp")

class VAST:
    def __init__(self, path, window, max_results=10):
        self.app = path
        self.window = window
        self.max_results = max_results
        log(f"capping VAST results at '{self.max_results}' events")

    def make_expression(self, intel):
        """Creates a VAST expression from an intel item."""
        # FIXME: type queries currently prevent this from working.
        #filter = '#type == "zeek::conn"'
        #if self.window:
        #    filter = f"#time > {self.window} ago && {filter}"
        #pred = VAST.make_predicate(intel.type, [intel.value])
        #return f'{filter} && {pred}'
        return VAST.make_predicate(intel.type, [intel.value])

    async def status(self):
        try:
            return json.loads(await spawn(self.app, "status"))
        except json.decoder.JSONDecodeError:
            fail(f"failed to connect to remote VAST node")
        except FileNotFoundError:
            fail(f"could not find {self.app} in PATH")

    async def export(self, expr, window=None):
        log(f"spawning {self.app} process for expression {expr}")
        stdout = await spawn(self.app, "export", "-e", str(self.max_results),
                             "json", expr)
        return stdout.splitlines()

    def path(self):
        """Retrieves the full path to the VAST binary"""
        return self.app

    @staticmethod
    def make_conjunction(xs):
        return "({})".format(" && ".join(xs))

    @staticmethod
    def make_disjunction(xs):
        return "({})".format(" || ".join(xs))

    @staticmethod
    def make_predicate(intel_type, values):
        assert values
        # Combine singleton values into a set query.
        def condense(lhs, rhs):
            if len(rhs) == 1:
                return f"{lhs} == {rhs[0]}"
            else:
                return f"{lhs} in {{{', '.join(rhs)}}}"
        # IP addresses
        if intel_type in ["ip-src", "ip-dst"]:
            return condense(":addr", values)
        # URLs
        elif intel_type in ["url", "uri"]:
            def make_http_log_expr(x):
                result = urllib.parse.urlsplit(x)
                host = result.hostname
                path = result.path
                if not host and path and path[0] != "/":
                    # If there is no protocol in the URI, then the "host" part will
                    # be prepended to "path". We're "fixing" this behavior by
                    # manually splitting at the first "/".
                    host, path = tuple(path.split("/", 1))
                    path = "/" + path # bring back leading slash
                host = f"host == {str_escape(host)}" if host else None
                path = f"uri == {str_escape(path)}" if path else None
                if host and path:
                    return VAST.make_conjunction([host, path])
                if host:
                    return host
                if path:
                    return path
                return None
            return VAST.make_disjunction(map(make_http_log_expr, values))
        # Domains
        elif intel_type == "domain":
            return condense("host", list(map(str_escape, values)))
        # Other
        elif intel_type == "http-method":
            return condense("method", list(map(str_escape, values)))
        else:
            fail("unsupported intel type:", intel_type)

class Zeek:
    def __init__(self, host, port):
        self.endpoint = broker.Endpoint()
        log(f"establishing peering with Zeek at {host}:{port}")
        self.endpoint.peer(host, port)
        log("established peering succesfully")

    def add(self, intel):
        """Forwards intelligence to Zeek"""
        log("forwarding intel to Zeek:", intel)
        event = broker.bro.Event(
            "Tenzir::add_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value,
            intel.source)
        self.endpoint.publish(ZEEK_TOPIC, event)

    def remove(self, intel):
        """Forwards intelligence to Zeek"""
        log("deleting intel from Zeek:", intel)
        event = broker.bro.Event(
            "Tenzir::remove_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value)
        self.endpoint.publish(ZEEK_TOPIC, event)

    @staticmethod
    def misp_to_intel_framework_type(intel):
        """Translates type names of internal intel to names in Zeek's intel
        framework."""
        # TODO: complete mapping MISP types to Zeek types.
        table = {
            "ip-src": "ADDR",
            "ip-dst": "ADDR",
            "domain": "DOMAIN",
            "email-dst": "EMAIL",
            "email-src": "EMAIL",
            "email-reply-to": "EMAIL",
            "hostname": "DOMAIN",
            "url": "URL",
            "uri": "URL",
            "x509-fingerprint-md5": "CERT_HASH",
            "x509-fingerprint-sha1": "CERT_HASH",
            "x509-fingerprint-sha256": "CERT_HASH",
        }
        return table[intel.type]


class Controller:
    def __init__(self, vast, misp, zeek):
        self.vast = vast
        self.misp = misp
        self.zeek = zeek

    async def run(self):
        while True:
            intel = await self.misp.intel()
            if self.vast:
                expr = self.vast.make_expression(intel)
                results = await self.vast.export(expr)
                log(f"reporting sightings for {len(results)} results")
                for result in results:
                    log(result, color="blue")
                    record = json.loads(result)
                    if "ts" not in record:
                        fail("couldn't find Zeek log with 'ts' column")
                    timestamp = int(record["ts"])
                    await self.misp.report(intel, timestamp)
            if self.zeek:
                self.zeek.add(intel)

# -- main ---------------------------------------------------------------------

async def main():
    """The main function"""
    parser = argparse.ArgumentParser(
        description="The Robo Investigor autonomously correlates threat "
        "intelligence with historical data to uncover attacks that began in "
        "the past. Matching activity is published back to the intelligence "
        "providers to confirm sightings",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "-m",
        "--misp-host",
        default=MISP_DEFAULT_HOST,
        help="The host where the MISP instance is running")
    parser.add_argument(
        "--misp-web-port",
        type=int,
        default=MISP_DEFAULT_WEB_PORT,
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "--misp-zmq",
        action="store_true",
        help="The ZeroMQ port of the MISP instance")
    parser.add_argument(
        "--misp-zmq-port",
        type=int,
        default=MISP_DEFAULT_ZMQ_PORT,
        help="The ZeroMQ port of the MISP instance")
    parser.add_argument(
        "--misp-kafka",
        action="store_true",
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "--misp-kafka-bootstrap-server",
        default=MISP_DEFAULT_KAFKA_BOOTSTRAP_SERVER,
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "--misp-kafka-attribute-topic",
        type=str,
        default=MISP_DEFAULT_KAFKA_ATTRIBUTE_TOPIC,
        help="The web UI port of the MISP instance")
    parser.add_argument(
        "-V",
        "--vast",
        action="store_true",
        help="Enable intelligence forwarding to VAST")
    parser.add_argument(
        "--vast-executable",
        default=which("tenzir"),
        help="Path to the VAST executable")
    parser.add_argument(
        "--vast-time-window",
        help="The time window to restrict intel searches to")
    parser.add_argument(
        "-Z",
        "--zeek",
        action="store_true",
        help="Enable intelligence forwarding to Zeek")
    parser.add_argument(
        "--zeek-host",
        default=ZEEK_DEFAULT_HOST,
        help="The host where Zeek integration runs")
    parser.add_argument(
        "--zeek-port",
        type=int,
        default=ZEEK_DEFAULT_PORT,
        help="The port where the Zeek integration listens")
    #parser.add_argument("values", nargs=argparse.REMAINDER)
    args = parser.parse_args()
    # Setup VAST
    vast = None
    if args.vast:
        if not args.vast_executable:
            fail(f"could not find VAST at {args.vast_executable}")
        vast = VAST(args.vast_executable, args.vast_time_window)
        vast_status = await vast.status()
        vast_threads = vast_status['system']['worker-threads']
        log(f"found VAST running with {vast_threads} threads")
    # Setup MISP.
    misp = MISP(args.misp_host, args.misp_web_port)
    if args.misp_kafka and args.misp_zmq:
        fail("cannot receive intel via both Kafka and 0mq")
    if args.misp_zmq:
        zmq_url = f"tcp://{args.misp_host}:{args.misp_zmq_port}"
        log(f"connecting to MISP 0mq socket at {zmq_url}")
        context = Context.instance()
        socket = context.socket(zmq.SUB)
        socket.connect(zmq_url)
        socket.setsockopt(zmq.SUBSCRIBE, b"")
        misp.subscribe(socket)
    elif args.misp_kafka:
        log("subscribing to MISP Kafka publisher at "
            f"{args.misp_kafka_bootstrap_server} at topic "
            f"{args.misp_kafka_attribute_topic}")
        consumer = AIOKafkaConsumer(
            args.misp_kafka_attribute_topic,
            loop=asyncio.get_event_loop(),
            bootstrap_servers=args.misp_kafka_bootstrap_server)
        await consumer.start()
        misp.subscribe(consumer)
    else:
        fail("need an intel subscription either via Kafka or 0mq")
    # Connect to Zeek.
    zeek = None
    if args.zeek:
        if not ZEEK_INTEGRATION:
            fail("no broker python module found")
        zeek = Zeek(args.zeek_host, args.zeek_port)
    # Create controller.
    if not (args.vast or args.zeek):
        fail("no intel consumer provided; enable VAST or Zeek")
    controller = Controller(vast, misp, zeek)
    log(f"waiting for new intel")
    await controller.run()

if __name__ == '__main__':
    asyncio.run(main())
