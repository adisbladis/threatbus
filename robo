#!/usr/bin/env python

import argparse
import asyncio
import confuse
import datetime
import json
import logging
import os
from shutil import which
import sys
from typing import NamedTuple
import urllib.parse

def str_escape(x):
    return '"' + x.replace('"','\\"') + '"'

async def spawn(*args):
    """Spawns a process asynchronously."""
    proc = await asyncio.create_subprocess_exec(
        *args,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE)
    stdout, stderr = await proc.communicate()
    logger = logging.getLogger("robo")
    logger.debug(stderr.decode().strip())
    return stdout.decode().strip()

class Intelligence(NamedTuple):
    id: str         # A unique identifier (within the intel source's context).
    type: str       # The type of intelligence.
    value: str      # The value of the item.
    data: str       # The raw data as given by the source
    source: str     # The origin of the intelligence.

class MISP:
    def __init__(self, config, generator):
        assert generator
        self.logger = logging.getLogger("robo.misp")
        self.generator = generator
        # Connect to MISP instance via API.
        api_key = None
        if "MISP_API_KEY" in os.environ:
            api_key = os.environ['MISP_API_KEY']
        elif config.rest.api_key:
            api_key = config.rest.api_key
        else:
            self.logger.critical("no MISP API key found: use MISP_API_KEY "
                                 "environment variable or config file")
        self.logger.info(f"connecting to MISP REST API at {config.rest.url}")
        try:
            self.misp = pymisp.PyMISP(config.rest.url, config.rest.api_key,
                               ssl=config.rest.ssl)
        except pymisp.PyMISPError:
            self.logger.critical("connection refused while trying to connect "
                                 f"to {api_url}")

    async def intel(self):
        """Generates the next intelligence item."""
        # TODO: support deletion of events
        while True:
            data = await self.generator()
            intel = self.__make_intel_from_attribute(data)
            if intel:
                return intel

    async def report(self, intel, time_seen):
        """Reports intelligence as (true-positive) sighting."""
        x = pymisp.MISPSighting()
        x.from_dict(id=intel.id, source="VAST", type="0", timestamp=time_seen)
        ts = datetime.datetime.utcfromtimestamp(time_seen)
        self.logger.debug(f"reporting intel seen at",
                          ts.strftime('%Y-%m-%d %H:%M:%S'))
        self.misp.set_sightings(x)

    async def __search(self, values, attr_type=None, start=None):
        """Performs a search over MISP attributes"""
        self.logger.debug("searching MISP database for", values)
        if attr_type:
            self.logger.debug("restricting search to type", attr_type)
        return self.misp.search(controller="attributes",
                                date_from=start,
                                type_attribute=attr_type,
                                values=values,
                                pythonify=True)

    def __make_intel_from_attribute(self, data):
        attr = data["Attribute"]
        action = data["action"]
        # Consider only new events.
        if action not in ["add", "edit"]:
            self.logger.debug(f"ignoring '{action}' of attribute {attr['id']}")
            return None
        # Instantiate the intel item.
        misp_attr = pymisp.MISPAttribute()
        misp_attr.from_dict(**attr)
        return Intelligence(
            id=misp_attr.id,
            type=misp_attr.type,
            value=misp_attr.value,
            data=misp_attr,
            source="misp")

class VAST:
    def __init__(self, config):
        self.logger = logging.getLogger("robo.vast")
        self.app = config.executable
        self.window = config.time_window
        self.max_results = config.max_results
        self.logger.debug(f"capping VAST results at '{self.max_results}' events")

    def make_expression(self, intel):
        """Creates a VAST expression from an intel item."""
        # FIXME: type queries currently prevent this from working.
        #filter = '#type == "zeek::conn"'
        #if self.window:
        #    filter = f"#time > {self.window} ago && {filter}"
        #pred = VAST.make_predicate(intel.type, [intel.value])
        #return f'{filter} && {pred}'
        return VAST.make_predicate(intel.type, [intel.value])

    async def status(self):
        try:
            return json.loads(await spawn(self.app, "status"))
        except json.decoder.JSONDecodeError:
            self.logger.critical(f"failed to connect to remote VAST node")
        except FileNotFoundError:
            self.logger.critical(f"could not find {self.app} in PATH")

    async def export(self, expr, window=None):
        self.logger.debug(f"spawning {self.app} process for expression {expr}")
        stdout = await spawn(self.app, "export", "-e", str(self.max_results),
                             "json", expr)
        return stdout.splitlines()

    def path(self):
        """Retrieves the full path to the VAST binary"""
        return self.app

    @staticmethod
    def make_conjunction(xs):
        return "({})".format(" && ".join(xs))

    @staticmethod
    def make_disjunction(xs):
        return "({})".format(" || ".join(xs))

    @staticmethod
    def make_predicate(intel_type, values):
        assert values
        # Combine singleton values into a set query.
        def condense(lhs, rhs):
            if len(rhs) == 1:
                return f"{lhs} == {rhs[0]}"
            else:
                return f"{lhs} in {{{', '.join(rhs)}}}"
        # IP addresses
        if intel_type in ["ip-src", "ip-dst"]:
            return condense(":addr", values)
        # URLs
        elif intel_type in ["url", "uri"]:
            def make_http_log_expr(x):
                result = urllib.parse.urlsplit(x)
                host = result.hostname
                path = result.path
                if not host and path and path[0] != "/":
                    # If there is no protocol in the URI, then the "host" part will
                    # be prepended to "path". We're "fixing" this behavior by
                    # manually splitting at the first "/".
                    host, path = tuple(path.split("/", 1))
                    path = "/" + path # bring back leading slash
                host = f"host == {str_escape(host)}" if host else None
                path = f"uri == {str_escape(path)}" if path else None
                if host and path:
                    return VAST.make_conjunction([host, path])
                if host:
                    return host
                if path:
                    return path
                return None
            return VAST.make_disjunction(map(make_http_log_expr, values))
        # Domains
        elif intel_type == "domain":
            return condense("host", list(map(str_escape, values)))
        # Other
        elif intel_type == "http-method":
            return condense("method", list(map(str_escape, values)))
        else:
            self.logger.critical("unsupported intel type:", intel_type)

class Zeek:
    def __init__(self, config):
        self.logger = logging.getLogger("robo.zeek")
        self.config = config
        self.endpoint = broker.Endpoint()
        self.logger.info("establishing peering with Zeek at "
                         f"{config.host}:{config.port}")
        self.endpoint.peer(config.host, config.port)
        self.logger.info("established peering succesfully")

    def add(self, intel):
        """Forwards intelligence to Zeek"""
        self.logger.debug(f"forwarding intel to Zeek: {intel}")
        event = broker.bro.Event(
            "Tenzir::add_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value,
            intel.source)
        self.endpoint.publish(self.config.topic, event)

    def remove(self, intel):
        """Forwards intelligence to Zeek"""
        self.logger.debug(f"deleting intel from Zeek: {intel}")
        event = broker.bro.Event(
            "Tenzir::remove_intel",
            Zeek.misp_to_intel_framework_type(intel),
            intel.value)
        self.endpoint.publish(self.config.topic, event)

    @staticmethod
    def misp_to_intel_framework_type(intel):
        """Translates type names of internal intel to names in Zeek's intel
        framework."""
        # TODO: complete mapping MISP types to Zeek types.
        table = {
            "ip-src": "ADDR",
            "ip-dst": "ADDR",
            "domain": "DOMAIN",
            "email-dst": "EMAIL",
            "email-src": "EMAIL",
            "email-reply-to": "EMAIL",
            "hostname": "DOMAIN",
            "url": "URL",
            "uri": "URL",
            "x509-fingerprint-md5": "CERT_HASH",
            "x509-fingerprint-sha1": "CERT_HASH",
            "x509-fingerprint-sha256": "CERT_HASH",
        }
        return table[intel.type]


class Controller:
    def __init__(self, vast, misp, zeek):
        self.logger = logging.getLogger("robo.controller")
        self.vast = vast
        self.misp = misp
        self.zeek = zeek

    async def run(self):
        while True:
            intel = await self.misp.intel()
            if not intel:
                return
            if self.vast:
                expr = self.vast.make_expression(intel)
                results = await self.vast.export(expr)
                self.logger.info(f"reporting sightings for {len(results)} results")
                for result in results:
                    self.logger.debug(result)
                    record = json.loads(result)
                    if "ts" not in record:
                        self.logger.critical("couldn't find Zeek log with 'ts' column")
                    timestamp = int(record["ts"])
                    await self.misp.report(intel, timestamp)
            if self.zeek:
                self.zeek.add(intel)

# -- main ---------------------------------------------------------------------

# The valid schema for the configuration.
log_levels = confuse.Choice(['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG'])
template = {
    'logger': {
        'console': bool,
        'file': bool,
        'filename': str,
        'console_verbosity': log_levels,
        'file_verbosity': log_levels,
    },
    'consumers': confuse.StrSeq(),
    'producers': confuse.StrSeq(),
    'misp': {
        'channel': confuse.OneOf(['zmq', 'kafka']),
        'zmq': {
            'host': str,
            'port': int,
        },
        'kafka': {
            'attribute_topic': str,
            'config': dict,
        },
        'rest': {
            'url': str,
            'ssl': bool,
            'api_key': str,
        }
    },
    'zeek': {
        'host': str,
        'port': int,
        'topic': str,
    },
    'vast': {
        'executable': str,
        'max_results': int,
        'time_window': str,
    },
}

async def main():
    """The main function"""
    # Setup configuration
    lazy_config = confuse.LazyConfig('RoboInvestigator', __name__)
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--config',
        '-c',
        help='path to a configuration file')
    parser.add_argument(
        '--quiet',
        '-q',
        dest='logger.console',
        action='store_false',
        help='do not log to console')
    # MISP
    parser.add_argument(
        "--misp-rest-uri",
        "-m",
        dest="misp.rest.url",
        help="The REST API host of the MISP instance")
    parser.add_argument(
        "--misp-zmq-host",
        "-0",
        dest="misp.zmq.host",
        help="The ZMQ host configured with MISP")
    parser.add_argument(
        "--zeek-host",
        "-z",
        dest="zeek.host",
        help="The Zeek host running the integration scripts")
    args = parser.parse_args()
    if args.config:
        lazy_config.set_file(args.config)
    lazy_config.set_args(args, dots=True)
    config = lazy_config.get(template)
    # Setup logging.
    logger = logging.getLogger('robo')
    logger.setLevel(logging.DEBUG) # FIXME: compute min(file, console)
    formatter = logging.Formatter('%(asctime)s %(levelname)-8s [%(name)s] '
                                  '%(message)s')
    if config.logger.file:
        fh = logging.FileHandler(config.logger.filename)
        fh.setLevel(config.logger.file_verbosity)
        fh.setFormatter(formatter)
        logger.addHandler(fh)
    if config.logger.console:
        ch = logging.StreamHandler()
        ch.setLevel(config.logger.console_verbosity)
        ch.setFormatter(formatter)
        logger.addHandler(ch)
    class ShutdownHandler(logging.Handler):
        def emit(self, record):
            logging.shutdown()
            sys.exit(1)
    sh = ShutdownHandler(level=50)
    sh.setFormatter(formatter)
    logger.addHandler(sh)
    # Setup VAST
    vast = None
    if "vast" in config.consumers:
        if not config.vast.executable:
            logger.critical(f"could not find VAST at {config.vast.executable}")
        vast = VAST(config.vast)
        vast_status = await vast.status()
        vast_threads = vast_status['system']['worker-threads']
        logger.info(f"found VAST running with {vast_threads} threads")
    # Setup MISP.
    misp = None
    if "misp" in config.producers:
        generator = None
        if config.misp.channel == "zmq":
            import zmq
            from zmq.asyncio import Context
            zmq_url = f"tcp://{config.misp.zmq.host}:{config.misp.zmq.port}"
            logger.info(f"connecting to MISP 0mq socket at {zmq_url}")
            context = Context.instance()
            socket = context.socket(zmq.SUB)
            socket.connect(zmq_url)
            socket.setsockopt(zmq.SUBSCRIBE, b"")
            async def generate():
                try:
                    while True:
                        msg = await socket.recv()
                        topic, _, payload = msg.decode("utf-8").partition(" ")
                        # Filter out heartbeats.
                        if topic == "misp_json_self":
                            uptime = int(json.loads(payload)["uptime"])
                            delta = datetime.timedelta(seconds=uptime)
                            logger.debug("received 0mq keep-alive (uptime "
                                         "{:0>8})".format(str(delta)))
                            continue
                        if topic != "misp_json_attribute":
                            continue
                        # Parse the payload.
                        data = json.loads(payload)
                        logger.debug(f"got attribute via 0mq: {data}")
                        return data
                except:
                    socket.disconnect()
            generator = generate
        elif config.misp.channel == "kafka":
            from confluent_kafka import Consumer, KafkaError
            logger.info("subscribing to MISP Kafka at topic "
                        f"{config.misp.kafka.attribute_topic}")
            logger.debug(f"launching Kafka with {config.misp.kafka.config}")
            consumer = Consumer(config.misp.kafka.config)
            consumer.subscribe([config.misp.kafka.attribute_topic])
            async def generate():
                try:
                    while True:
                        msg = consumer.poll(0)
                        if msg is None:
                            continue
                        if msg.error():
                            if msg.error().code() != KafkaError._PARTITION_EOF:
                                logger.error(f"got Kafka error: {msg.error()}")
                            continue
                        data  = json.loads(msg.value())
                        logger.debug(f"got Kafka message: {data}")
                        return data
                except:
                    logger.debug("leaving Kafka group and committing offsets")
                    consumer.close()
            generator = generate
        else:
            logger.critical("need an intel subscription either via Kafka or 0mq")
        globals()["pymisp"] = __import__("pymisp")
        misp = MISP(config.misp, generator)
    # Connect to Zeek.
    zeek = None
    if "zeek" in config.consumers:
        globals()["broker"] = __import__("broker")
        globals()["broker.bro"] = __import__("broker.bro")
        zeek = Zeek(config.zeek)
    # Create controller.
    if not misp:
        logger.critical("MISP intel producer not provided") # currently mandatory
    if not (vast or zeek):
        logger.critical("no intel consumer provided; enable VAST or Zeek")
    controller = Controller(vast, misp, zeek)
    logger.info("waiting for new intel")
    await controller.run()

if __name__ == '__main__':
    if sys.version_info == (3, 6):
        loop = asyncio.get_event_loop()
        loop.run_until_complete(main())
        loop.close()
    else:
        assert sys.version_info >= (3, 7)
        asyncio.run(main())
